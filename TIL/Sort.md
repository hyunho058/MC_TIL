# Sort

> 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순), 혹은 반대의 순서대로(내림차순) 재배열 하는 것



* Sort 종류
  * Bubble Sort(버블 정렬)
  * Counting Sort(카운팅 정렬)
  * Selection Sort(선택 정렬)
  * Quick Sort(퀵 정렬)
  * Insertion Sort(삽입 정렬)
  * Merge Sort(병합 정렬)



## Bubble Sort

> 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

* 정렬 과정
  * 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
  * 한 단계가 끝나면 가장 큰 원소 또는 가장 작은 원소가 마지막 자리로 정렬됨
* 교환하여 자리를 디오하는 모습이 ㅉ물 위에 올라오는 거품모양과 같다고 하여  Bubble Sort
* 시간 복잡도
  * O(n제곱)
* 예시
  * 55, 8, 78, 12, 42를 Bubble Sort 하는 과정
    1. 55, 7, 78, 12, 42
    2. 7, 55, 78, 12, 42
    3. 7, 55, 78, 12, 42
    4. 7, 55, 12, 78, 42
    5. 7, 55, 12, 42, 78
    6. 7, 55, 12, 42, 78
    7. 7, 12, 55, 42, 78
    8. 7, 12, 42, 55, 78
  * 가장 마지막 부분부터 정렬이 완료되고 나머지 범위에서 정렬을 반봅한다.



## Counting Sort

> 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 Algorithm

* 제한 사항
  * 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
    * 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스되는 카운트들의 배열을 사용하기 때문
  * 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함.
* 시간 복잡도
  * O(n + k) - n은 항목의 개수, k는 정수의 최대 값
* 예시
  * 0, 4, 1, 3, 1, 2, 4, 1을 정렬하는 과정
    1. Data에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 COUNTS에 저장
       - COUNTS = {1, 3, 1, 1, 2}
    2. 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 COUNTS의 원소를 조정
       - COUNTS = {1, 4, 5, 6, 8}
       - 해당 원소가 정렬될 때 배열의 몇 번째 위치에 들어가야 하는지를 보여줌
    3. COUNTS[1]을 감소시키고 TEMP에 1을 삽입
       - COUNTS[1]의 값이 4임을 확인하고 TEMP[4]에 1을 삽입하고 COUNTS[1]을 3으로 줄임
    4. 같은 방식으로 Data 배열을 전부 진행